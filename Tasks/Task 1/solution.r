#задание 2
print ("task 2")
A <- matrix (c(1,5,13,14,-12,-4,11,-13,9,3,-8,-1,-5,7,0,-11,0,-6,3,13,12,0,4,2,8,6,12,-11,4,10,13,-1,5,0,5,4),6,6)
A
#определитель
det(A) # Определитель A

#задание 4
print ("task 4")
A <- matrix (c(7,-8,2,-5,1,7,-5,-7,3,-7,8,-4,9,5,0,-12,8,8,-10,5,-6,-2,-10,-7,0,1,5,5,12,-1,3,10,5,8,-5,-5),6,6)
A
B <- matrix (c(3,4,-7,-2,-9,-9,-1,-3,2,0,8,5,-5,9,5,0,-4,-2,8,7,0,3,-2,0,-8,-3,0,8,1,8,-2,-3,1,0,-4,-2),6,6)
B
x <- solve(B,A)
print ("x равен")
x

#задание 5
print ("5 task")
a <- c(3,3,-2,1,2,3,-4,0,-1,2,3,3)
b <- c(-2,3,3,1,1,1,0,-1,2,4,-4,2)
p <- c(4,2,2,2,5,1,3,3,0,-3,-2,-1)

fir <- ((3)*a)+(4*b)
print ("first answer")
fir
sec <- ((2)*as.numeric(a%*%b))*p-1*(norm(p, type="2"))*a
print ("second answer")
sec
thr <- 3*as.numeric(a%*%p)*b-2*as.numeric(b%*%p)*a-2*(norm(p, type="2"))*p
print ("third answer")
thr

#6 задание
print ("sixth task")
install.packages("lpSolveAPI") # Загружаем библиотеку
library(lpSolveAPI) # Активируем библиотеку линейного программирования
M <- make.lp(ncol= 2) # Объявляем количество неотрицательных переменных в M
name.lp(M, "Example") # Объявляем название "Example"для задачи(модели) М
colnames(M) <- c("X1", "X2") # Объявляем названия переменных в модели М
lp.control(M, sense = "max")$sense# Объявляем задачу на минимум модели М
set.objfn(M, c(1,1)) # Задаем целевую функцию:
add.constraint(M, c(2,1), "<=", 20) # Задаем ограничение:
add.constraint(M, c(0.7, 2.1), ">=",30) #

rownames(M) <- c("A", "B") # Называем ограничения в модели М
M # Выводим модель M на экран
solve.lpExtPtr(M)
get.variables(M) # Оптимальный план
get.objective(M) # Достигнутый min
X1.opt<- get.variables(M)[1]; X1.opt # Оптимальное значение для X1
X2.opt<- get.variables(M)[2]; X2.opt # Оптимальное значение для X2
f.max<- get.objective(M); f.max# Значение целевой функции на оптимальном решении
