#задание 2
print ("task 2")
A <- matrix (c(0,-12,-11,13,11,11,-3,12,9,-11,12,-13,0,-8,11,14,14,-13,7,8,-1,-10,14,-6,-2,-14,-7,8,1,14,13,9,-6,7,-3,2),6,6)
A
#определитель
det(A) # Определитель A

#задание 4
print ("task 4")
A <- matrix (c(-1,3,-5,0,0,-7,-1,-3,10,-6,-1,6,-3,4,-9,1,7,-8,5,12,4,-12,10,5,-2,-12,-7,-5,-6,-4,7,-9,11,-2,5,5),6,6)
A
B <- matrix (c(-6,1,8,6,5,2,6,3,-6,-6,9,-2,3,5,2,0,-3,9,4,-1,-6,4,-1,1,6,-9,0,6,5,1,8,-6,8,-4,-1,0),6,6)
B
x <- solve(B,A)
print ("x равен")
x

#задание 5
print ("5 task")
a <- c(0,-4,2,3,1,1,1,0,-5,-2,-1,3)
b <- c(-4,-4,0,3,-2,-1,-2,3,3,1,1,5)
p <- c(1,5,2,4,3,0,-4,-5,1,2,2,1)

fir <- ((7)*a)+(4*b)
print ("first answer")
fir
sec <- ((9)*as.numeric(a%*%b))*p-2*(norm(p, type="2"))*a
print ("second answer")
sec
thr <- 1*as.numeric(a%*%p)*b-2*as.numeric(b%*%p)*a-2*(norm(p, type="2"))*p
print ("third answer")
thr

#6 задание
print ("sixth task")
install.packages("lpSolveAPI") # Загружаем библиотеку
library(lpSolveAPI) # Активируем библиотеку линейного программирования
M <- make.lp(ncol= 2) # Объявляем количество неотрицательных переменных в M
name.lp(M, "Example") # Объявляем название "Example"для задачи(модели) М
colnames(M) <- c("X1", "X2") # Объявляем названия переменных в модели М
lp.control(M, sense = "max")$sense# Объявляем задачу на минимум модели М
set.objfn(M, c(2,1)) # Задаем целевую функцию:
add.constraint(M, c(4,3), "<=", 1) # Задаем ограничение:
add.constraint(M, c(-0.2, -0.6), ">=",-1.5) #

rownames(M) <- c("A", "B") # Называем ограничения в модели М
M # Выводим модель M на экран
solve.lpExtPtr(M)
get.variables(M) # Оптимальный план
get.objective(M) # Достигнутый min
X1.opt<- get.variables(M)[1]; X1.opt # Оптимальное значение для X1
X2.opt<- get.variables(M)[2]; X2.opt # Оптимальное значение для X2
f.max<- get.objective(M); f.max# Значение целевой функции на оптимальном решении
