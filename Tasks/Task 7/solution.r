print ("first task")

a <- c(-5, 1, 6, -3, 2, -2, 5, 2, 0, -6, 2, 1, 0, -2, -3, 1)
b <- c(3, -2, 6, -4, -7, 8, -1, 0, 9, -2, 8, 9, -2, 1, 0, -1)
p <- c ( -8, 4, -2, 8, 0, 3, -5, 3, 2, -3, -4, 5, 9, 1, -3, 0)
fir <- ((5)*a)-(6*b)
print ("first answer")
fir
sec <- ((5)*as.numeric(a%*%p))*b+3*(norm(p, type="2"))*b
print ("second answer")
sec
thr <- (-2)*(norm(p, type="2"))*p+5*as.numeric(a%*%p)*a+3*as.numeric(b%*%p)*b
print ("third answer")
thr

2 задание

print ("second task")
mat <- rbind(c(-4,3,0,-10,8,0,0,0),c(12,-5,0,-1,8,0,0,0),c(-1,6,0,2,8,0,0,0),c(7,0,12,0,0,1,0,-3),c(-7,0,0,0,0,-1,-4,3),c(0,0,0,-3,-8,0,1,-2),c(0,0,0,8,-1,0,-4,-2),c(0,0,0,-6,2,0,-9,1))
rua <- c(34,44,-6,-44,-4,-61,-13,50)
X <- solve(mat)%*%rua
print ("Answer for the sec task")
X
mat%*%X
rua

4 задание

print ("fourth task")
A <- rbind(c(19, 0, 0, 0, 0 ,0 ,0 ,20),c(0, 7 ,0 ,0 ,7 ,0 ,0 ,0),c(0, 0, 13, 0, 0, 0, 0, 0),c(0 ,0 ,0 ,11, 0, 0, 0, 0),c(0 ,7 ,0 ,0, 17, 0, 0 ,0),c(0, 0, 0, 0, 0 ,5, 0, 0),c(0, 0, 0, 0, 0, 0, 3 ,0),c(0, 0, 0, 0, 0, 0, 0, 1))
A
options(digits=3) # Задать количество значащих цифр для вывода
print ("собственные числа ")
d <- eigen(A)$values; d # Собственные значения матрицы A
print ("собственные вектора")
P <- eigen(A)$vectors; P # Собственные векторы A, стоящие в столбцах матрицы
P
print (" Проверим ортогональность полученного собственного базиса ")
sum(P[,1]^2) # Например, длина первого собственного вектора
P[,1] %*% P[,2] # Например, скалярное произведение (f1, f2)
sum(P[,2]^2); P[,2] %*% P[,3] # длина 2 собственного вектора и (f2, f3)
sum(P[,3]^2); P[,3] %*% P[,4] # длина 3 собственного вектора и (f3, f4)
sum(P[,4]^2); P[,4] %*% P[,5] # длина 4 собственного вектора и (f4, f5)
sum(P[,5]^2); P[,5] %*% P[,6] # длина 5 собственного вектора и (f5, f6)
sum(P[,6]^2); P[,6] %*% P[,7] # длина 6 собственного вектора и (f6, f7)
sum(P[,7]^2); P[,7] %*% P[,8] # длина 7 собственного вектора и (f7, f8)
sum(P[,8]^2); P[,8] %*% P[,1] # длина 8 собственного вектора и (f8, f1)
print ("Таким образом, получили что полученный базис составляют нормированные и
ортогональные между собой вектора, т.е ортонормированный базис.
Таким образом, получили что полученный базис составляют нормированные и
ортогональные между собой вектора, т.е ортонормированный базис.")

6 задание

print ("sixth task")
install.packages("lpSolveAPI") # Загружаем библиотеку
library(lpSolveAPI) # Активируем библиотеку линейного программирования
M <- make.lp(ncol= 2) # Объявляем количество неотрицательных переменных в M
name.lp(M, "Example") # Объявляем название "Example"для задачи(модели) М
colnames(M) <- c("X1", "X2") # Объявляем названия переменных в модели М
lp.control(M, sense = "min")$sense# Объявляем задачу на минимум модели М
set.objfn(M, c(-6, 2)) # Задаем целевую функцию: f = 5*X1 +3*X2 для модели М
add.constraint(M, c(5,7), ">=", 35) # Задаем ограничение:
add.constraint(M, c(-3, 9/2), ">=", -27/2) # Аналогично
add.constraint(M, c(1, -3), ">=", -12) # Аналогично
add.constraint(M, c(1, 0), "<=", 8) # Аналогично
rownames(M) <- c("A", "B", "C", "D") # Называем ограничения в модели М
M
solve.lpExtPtr(M)
get.variables(M) # Оптимальный план
get.objective(M)
X1.opt<- get.variables(M)[1]; X1.opt # Оптимальное значение для X1
X2.opt<- get.variables(M)[2]; X2.opt # Оптимальное значение для X2
f.max<- get.objective(M); f.max
